# dswt

I got bored and decided to make my own web-token format. 
I do not reccomend using it in production for the time being, 
there are definitely many issues, I am still writing the spec,
Use at your own risk.
This is moreso just a hobby project for me. 

## Definitions

## Versions

The structure of the tokens version identifier is `DSWT-<num>[-T]` 
where `<num>` is the first version of this crates semver version number. 
The `-T` is optional and is used to indicate that the token has type information.

### Type Information

Type information is a feature that allows the token to store the type of each value in the payload.
This is useful when serializing and deserializing the token 
as it allows the library to automatically convert the data to the correct type.
The following types are supported:

- `UUID` - A Universally Unique Identifier
- `string` - A list of characters
- `int` - A signed integer
- `float` - A floating-point number
- `bool` - A boolean value

## Token Structure

The token is made up of 3 parts; a header, a payload, and a signature separated by semicolons (`;`).

### Header

The header is a base64-encoded string split with a slash (`/`) into two values 
(e.g. decoded: `DSWT-0/HS256`, see [Versions](#versions) for more information on the version identifier).
The first value is always the version of the token format,
the second value is the algorithm used to sign the token. 

### Payload

The payload is a base64-encoded CSV string. 
Depending on if the token has type information, each value could be structured differently.

#### Typed

If the token has type information, each value is structured as follows:
`<key>:<type>=<data>` where `<key>` is a unique identifier
`<type>` is the type of the value, and `<data>` is the data stored. 

#### Untyped

If the token does not have type information, each value is structured as follows:
`<key>=<data>` where `<key>` is a unique identifier and `<data>` is the data stored.

- [ ] TODO: add untyped key generation to the library


### Signature

The signature is a base64-encoded string that is used to verify the integrity of the token.
The signature is generated by hashing the header and payload with the algorithm specified in the header.
So far, the only supported algorithm is HMAC-SHA256, I plan to add more in the future.

- [ ] TODO: figure out best way to store the pk for the signature
- [ ] TODO: add more algorithms


## Examples

TODO

## Why not use JWT?

Like I said previously, this is moreso for fun and learning.
I am however using it in actual projects 
(a la [netter](https://github.com/netterapp) and [smple](https://github.com/AmmoniumStudios/smple)). 
I'm personally not a big fan of jwt's, I think they can be a lot simpler. 
